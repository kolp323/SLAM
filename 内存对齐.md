### Sophus/Eigen 
Sophus/Eigen 的类里有 SSE/AVX 对齐要求，错配就会导致“corrupted double-linked list”这种堆链表损坏。  
```add_definitions(-DEIGEN_DONT_ALIGN_STATICALLY)```  

### 确保 Eigen 的内存对齐支持
```add_definitions(-DEIGEN_DONT_VECTORIZE -DEIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)```  


### -DEIGEN_DONT_ALIGN_STATICALLY
作用：这个宏告诉 Eigen 不要对静态（static）和栈（stack）上的对象进行内存对齐。  

适用场景：当你使用 Eigen 对象作为 std::vector 的元素或者在其他不支持内存对齐的容器中使用时，应该使用这个宏。这是因为 std::vector 无法保证其内部元素的内存是对齐的。通过禁用静态对齐，可以避免在运行时因访问未对齐内存而导致的崩溃（Segmentation Fault）。  

缺点：禁用静态对齐可能会导致性能损失，因为编译器无法使用 SIMD 指令（如 SSE/AVX）来加速计算。  

### -DEIGEN_DONT_VECTORIZE  
### -DEIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT
作用：这个组合宏更加激进，它从根本上禁用了 Eigen 的向量化功能和内存对齐断言。

-DEIGEN_DONT_VECTORIZE：这个宏完全禁用了 Eigen 库的向量化功能。这意味着 Eigen 不会生成利用 SSE/AVX 等指令集的代码，所有操作都会使用普通的循环和标量操作。

-DEIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT：这个宏禁用了 Eigen 的一个断言检查。在默认情况下，如果你尝试使用未对齐的内存，Eigen 会在调试模式下抛出断言错误。禁用这个断言可以防止程序在运行时因对齐问题而终止。

适用场景：当你确定程序在处理 Eigen 对象时会遇到内存对齐问题，并且不想花时间去解决它时。这通常被用作一个快速的临时解决方案，来防止程序崩溃。

缺点：禁用向量化会显著降低 Eigen 的性能，因为向量化是 Eigen 库速度优势的主要来源。

